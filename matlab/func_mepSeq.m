function [M_SSR, M1_seq, M_coordDiff, check1, check2, check3, ...
    M_SIZE, M2_seq, M_length, M_section, M_seq, tableCompo_mep2, recordCompoInClusterIdx, tableZoned_mep2, ...
    M_clusterSeq_befSplit, tableAllCompoClusterBeforeSplit, ...
    seq_pred_mep_constSeq, seq_succ_mep_constSeq, seq_pred_mep_SR, seq_succ_mep_SR, buffer_mep_SR, ...
    clusterName_new, clusterSplitRecord, tableAllCompo_whenSplitting, M_clusterSeq_whenSplitting, ...
    clusterSplitRecord_befS2, tableCompo_mep2_befS2, seq_pred_mep_constSeq_befS2, seq_succ_mep_constSeq_befS2, ...
    seq_pred_mep_SR_befS2, seq_succ_mep_SR_befS2, toCreateNewSub, tableZoned_mep_splitted, clusterName_new_new] ...
    = func_mepSeq ...
    (tableCompo_mep, tableCompo_struct, Dmin_h, Dmin_v, Dwallmin, Dceilmin, ...
    Dmin_h2, Dmin_v2, D_length_long, D_length_short, D_crosssec_large, D_crosssec_small, ...
    tableActivity_mep, nClass_mep, nLevel, nZ, tableZoned_mep, compoClass_mep, nR, nM, nAllEleGuid)
%% SEQ MEP STEP 2 - SSR: find all pairs of compo with special spatial relations
[M_SSR, M1_seq, M_coordDiff, check1, check2, check3] = func_mepSeq_findSSR(tableCompo_mep, tableCompo_struct, ...
    Dmin_h, Dmin_v, Dwallmin, Dceilmin);


%% SEQ MEP STEP 2 - compo size: find all pairs of compo with compo size relations
[M_SIZE, M2_seq, M_length, M_section] = func_mepSeq_findCSR(tableCompo_mep, ...
    Dmin_h2, Dmin_v2, D_length_long, D_length_short, D_crosssec_large, D_crosssec_small, M_coordDiff);


%% SEQ MEP STEP 3 (added): combine M1_seq and M2_seq into one 
[M_seq] = func_mepSeq_findM_seq_fromSSRCSR(M1_seq, M2_seq);


%% SEQ MEP STEP 3: clustering: create groups and assign compo to groups + Map the duration and cost data
[tableCompo_mep2, recordCompoInClusterIdx, tableZoned_mep2] = func_mepSeq_findClusterNum_befSplit(tableCompo_mep, ...
    tableActivity_mep, nClass_mep, nLevel, nZ, tableZoned_mep, compoClass_mep);


%% SEQ MEP STEP 4: Prepare for the splitting
[M_clusterSeq_befSplit, tableAllCompoClusterBeforeSplit] = func_mepSeq_prepareForSplit(tableZoned_mep2, ...
    M_seq, recordCompoInClusterIdx);


%% SEQ MEP STEP 5: Split the clusters which contain conflicting prec results
[seq_pred_mep_constSeq, seq_succ_mep_constSeq, seq_pred_mep_SR, seq_succ_mep_SR, buffer_mep_SR, ...
    clusterName_new, clusterSplitRecord, tableAllCompo_whenSplitting, M_clusterSeq_whenSplitting] = ...
    func_mepSeq_findConstSeqAndSRSeq ...
    (tableZoned_mep2, ...
    M_clusterSeq_befSplit, tableAllCompoClusterBeforeSplit, nZ);


%% SEQ MEP STEP 6: Find the (sub)cluster number for each component
[tableCompo_mep2, seq_pred_mep_constSeq, seq_succ_mep_constSeq, seq_pred_mep_SR, seq_succ_mep_SR,  ...
    clusterSplitRecord_befS2, tableCompo_mep2_befS2, seq_pred_mep_constSeq_befS2, seq_succ_mep_constSeq_befS2, ...
    seq_pred_mep_SR_befS2, seq_succ_mep_SR_befS2, toCreateNewSub, clusterSplitRecord] = ...
    func_mepSeq_handleNoInterclusterConflictCompo ...
    (tableCompo_mep2, clusterName_new, clusterSplitRecord, ...
    M_clusterSeq_befSplit, tableAllCompo_whenSplitting, ...
    seq_pred_mep_constSeq, seq_succ_mep_constSeq, seq_pred_mep_SR, seq_succ_mep_SR);


%% Write a new tableZoned_splitted, with cost and duration data and compo index
[tableZoned_mep_splitted, clusterName_new_new] = ...
    func_mepSeq_createTableZoned_mep ...
    (tableZoned_mep2, tableCompo_mep2, tableActivity_mep, clusterSplitRecord, ...
    nR, nM, nAllEleGuid);
